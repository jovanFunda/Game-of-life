# -*- coding: utf-8 -*-
"""Game of life 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O03NTETYdqrW57DTYLYUDZm7syTkQnLV
"""

from matplotlib.animation import FuncAnimation
import matplotlib.pyplot as plt
from IPython.display import HTML
import numpy as np
import random
import multiprocessing

def animate(steps):
  ''' Prima niz matrica (svaka matrica je stanje u jednom koraku simulacije) 
  prikazuje razvoj sistema'''
  
  def init():
    image.set_data(steps[0])
    return [image]
  
  def animate1(i):
    image.set_data(steps[i])
    return [image]

  image = plt.matshow(steps[0], interpolation='None', animated=True);
  
  animation = FuncAnimation(image.get_figure(), animate1, init_func=init,
                  frames=len(steps), interval = 250, blit=True, repeat=False);
  return animation

def find_new_state(curr_state, neighbors):

  state = curr_state
  if neighbors < 2 or neighbors > 3:
    state = 0
  elif curr_state == 1 and (neighbors == 2 or neighbors == 3):
    state = 1
  elif curr_state == 0 and neighbors == 3:
    state = 1

  return state

"""
Returns first and last index of rows that this parameter will work on
"""
def find_rows_to_work_on(parameter):
  if not (parameter == N-1):
    rows_working_on = (int)(width / N)
  else:
    rows_working_on = width - (int)(width / N) * (N-1)

  start_row = (int)(width / N) * parameter
  last_row = start_row + rows_working_on - 1

  return (start_row, last_row)

"""
Finds live neighbors depending on current x and y positions
"""
def live_neighbors(x, y):

  total = 0
  for i in range(-1, 2):
    for j in range(-1, 2):
      col = (x+i+width) % width
      row = (y+j+width) % width

      if not (i == 0 and j == 0):
        total += grid[iteration-1][col][row]

  return total    

def task(parameter):
  start_row, ending_row = find_rows_to_work_on(parameter)
  values = []

  for x in range(start_row, ending_row+1):
    for y in range(0, width):
      total = live_neighbors(x, y)
      values.append(find_new_state(grid[iteration-1][x][y], total))

  return [start_row, ending_row, values]

width = 50
max_iteration = 50
N = 5

grid = np.zeros((max_iteration, width, width))
iteration = 1

for i in range(width):
  for j in range(width):
    grid[0][i][j] = random.randint(0, 1)

while iteration < max_iteration:

  pool = multiprocessing.Pool(processes=N)

  results = [pool.apply_async(task, args=(i,)) for i in range(0,N)]
  output = [p.get() for p in results]

  for z in range(0, N):
    min_row = output[z][0]
    max_row = output[z][1]
    values = output[z][2]
    for row in range(min_row, max_row+1):
      for column in range(width):
        grid[iteration][row][column] = values[(row-min_row) * width + column]

  iteration += 1

animation = animate(grid)
HTML(animation.to_html5_video())