# -*- coding: utf-8 -*-
"""Game of life zadatak 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HTdyaRjx3qjZguM0-lRWO2a-omW25IMo
"""

from matplotlib.animation import FuncAnimation
import matplotlib.pyplot as plt
from IPython.display import HTML
import numpy as np
import threading
import random

def animate(steps):
  ''' Prima niz matrica (svaka matrica je stanje u jednom koraku simulacije) 
  prikazuje razvoj sistema'''
  
  def init():
    im.set_data(steps[0])
    return [im]
  
  
  def animate(i):
    im.set_data(steps[i])
    return [im]

  im = plt.matshow(steps[0], interpolation='None', animated=True);
  
  anim = FuncAnimation(im.get_figure(), animate, init_func=init,
                  frames=len(steps), interval=250, blit=True, repeat=False);
  return anim

def check_neighbors(x, y):
  total = 0
  global state_grid
  global counter_neighbors

  for i in [-1, 0, 1]:
    for j in [-1, 0, 1]:
      col = (x+i+width) % width
      row = (y+j+width) % width

      if not (i == 0 and j == 0):
        total += state_grid[col][row]
        counter_neighbors[col][row] += 1
        if counter_neighbors[col][row] == 8: # Neki komsija je procitao 8 komsija
          counter_neighbors[col][row] = 0
          semaphore_grid[col][row].release()
      
  return total

def find_new_state(state, neighbors):
  if neighbors < 2 or neighbors > 3:
    return 0
  elif state == 1 and (neighbors == 2 or neighbors == 3):
    return 1
  elif state == 0 and neighbors == 3:
    return 1
  else:
    return state

def cell(x, y):
  iteration = 1
  global cell_counter
  global state_grid

  while iteration < max_iteration:

    neighbors = check_neighbors(x, y) # Proverava broj komsija

    semaphore_grid[x][y].acquire()

    state_grid[x][y] = find_new_state(state_grid[x][y], neighbors) # Trazi novo stanje
    grid[iteration][x][y] = state_grid[x][y]

    condition.acquire()
    cell_counter+=1  # Koliko je ukupno celija zavrsilo svoju iteraciju

    if cell_counter != width*width:
      condition.wait()
    else:
      cell_counter = 0
      condition.notifyAll() # Kada poslednja celija zavrsi obradu ona ce javiti svim ostalima 

    condition.release()
    iteration+=1

width = 50
max_iteration = 50

cell_counter = 0
condition = threading.Condition()

state_grid = np.zeros((width, width))
grid = np.zeros(((max_iteration, width, width)))

counter_neighbors = [[0 for i in range(width)] for j in range(width)] # Lista brojaca suseda koji su procitali trenutnu vrednost
semaphore_grid = [[0 for i in range(width)] for j in range(width)]

ts = [[0 for i in range(width)] for j in range(width)]

for i in range(width):
  for j in range(width):
    grid[0][i][j] = random.randint(0, 1)
    state_grid[i][j] = grid[0][i][j]
    semaphore_grid[i][j] = threading.Semaphore(0)
    ts[i][j] = threading.Thread(target=cell,args=(i,j))

for i in range(width):
  for j in range(width):
    ts[i][j].start()

for i in range(width):
  for j in range(width):
    ts[i][j].join()

anim = animate(grid)
HTML(anim.to_html5_video())